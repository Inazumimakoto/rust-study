# 第2章: 数当てゲーム

## 📅 学習日
2026-01-01

## 🛠 やったこと

### 数当てのMVPを作った！

![MVP実行結果](../images/ch02_guessing_mvp.png)

---

## 📝 学習メモ

### `use std::io`

`std` という標準ライブラリの `io` を取り込む．なんかC++みたい！！`std::cin`, `std::cout`!!

### `let mut guess = String::new();`

出ました謎構文．Rustっぽくて楽しくなってきた！

#### `let`
これは変数を作る！ってこと！

> 💡 **補足**: C++だと `int x = 5;` みたいに型を前に書くけど、Rustは `let x: i32 = 5;` みたいに型は後ろ！しかも型推論が強力だから省略できることが多い！

| 言語 | 変数宣言 | 例 |
|------|----------|-----|
| C++ | 型名 | `int x = 5;` |
| Java | 型名 (+ `var`) | `int x = 5;` / `var x = 5;` |
| JavaScript | `let` / `const` | `let x = 5;` |
| Rust | `let` | `let x = 5;` |

Rustの整数型（C++の `int` 的なやつ）:
- `i32`: 32bit符号付き（デフォルト）
- `i64`: 64bit符号付き
- `u32`: 32bit符号なし

#### `mut`
可変ってこと！デフォルトは不変（イミュータブル）だから `mut` で変えれるようにする！

ここがすごくて、C++とかはデフォが可変で不変にしたいなら `const` をつけてたけど、それが逆！

#### `String::new()`
`String` の `new` 関数を呼び出してる．簡単に言えば初期化．
だから `String` 型の空の文字列を作ってるってこと！

> 💡 **補足**: `::` は型に関連付けられた関数（関連関数）を呼ぶ。C++の `static` メソッドに近い！

---

### 標準入力

```rust
io::stdin()
    .read_line(&mut guess)
    .expect("Failed to read line");
```

#### `io::stdin()`
ユーザーからの標準入力を処理できるようにする！`std::io::stdin()` でも同じようにできる！

#### `.read_line(&mut guess)`
標準入力を `guess` にいれてる！

ここでポイント：
- 明示的に `mut` を書かなきゃいけない
- `&` で参照渡しにしてる（参照はC++でやったから大丈夫！）

##### ❓ 宣言の時に `mut` ってやってるのに、ここでも `mut` 書くのはなんで？

> 💡 **回答**: 宣言時の `mut` と参照の `&mut` は別物！
> 
> | 何か | 意味 |
> |------|------|
> | `let mut guess` | 「この変数は**再代入できる**」 |
> | `&mut guess` | 「この参照は**中身を変更できる**」 |
> 
> ```rust
> // ❌ これはダメ
> io::stdin().read_line(&guess);  // 不変参照 → 中身変えられない！
> 
> // ✅ これがOK
> io::stdin().read_line(&mut guess);  // 可変参照 → 中身変えられる！
> ```
> 
> Rustは「参照を渡す時点で『変更していいよ』と明示的に許可」させる！安全！

#### `.expect()`
入力失敗した時のエラー処理もかける！！Javaと同じような感じ．

---

### 変数を出力

```rust
println!("You guessed: {}", guess);
```

`{}` で変数を出力したい時 `println!("{}",guess);` ってやる！これはもうC!

---

## 💡 学んだこと

- `use` で標準ライブラリをインポート（C++の `#include` 的な）
- `let` で変数宣言、`mut` で可変にする
- Rustはデフォルト不変！（C++と逆）
- `String::new()` で空の文字列作成
- `&mut` で可変参照を渡す（変更許可を明示！）
- `println!` の `{}` でフォーマット出力
