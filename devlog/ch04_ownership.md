# 第4章: 所有権を理解する

Rustの**最もユニークで重要な機能**！

## なぜ所有権が必要？

メモリ管理の歴史的な問題を解決するため！

### 従来の方法とそのデメリット

#### 方法1: 手動メモリ管理（C/C++）

```cpp
int* ptr = new int(42);  // 確保
// ...使用...
delete ptr;              // 解放
```

| デメリット | 説明 |
|-----------|------|
| メモリリーク💀 | `delete` 忘れ → メモリ食い尽くす |
| ダングリングポインタ💀 | 解放後にアクセス → クラッシュ or 未定義動作 |
| 二重解放💀 | 同じメモリを2回 `delete` → クラッシュ |
| 複雑💀 | どこで誰が解放するか追跡が地獄 |

**結論: C++は人間にメモリ管理を任せる → 人間はミスる → バグ祭り🤮**

---

#### 方法2: ガベージコレクション（Java, Python, Go等）

```java
Object obj = new Object();  // 確保
// ...使用...
// 解放は自動（GCに任せる）
```

| デメリット | 説明 |
|-----------|------|
| 実行時オーバーヘッド💀 | GCが動く度に処理が止まる（Stop the World） |
| 予測不能💀 | いつGCが走るかわからない |
| メモリ使用量増💀 | 解放が遅延するので使用量が増える |
| リアルタイム不向き💀 | ゲーム、組み込み系では致命的 |

**結論: 安全だけど遅い。パフォーマンスが犠牲になる。**

---

### 方法3: 所有権（Rust）🦀

**天才的アイデア！全く新しい第三の方法！**

```rust
let s = String::from("hello");  // 確保
// ...使用...
// スコープを抜けると自動で解放！
```

| 特徴 | 説明 |
|------|------|
| コンパイル時チェック✅ | 実行前にメモリ問題を検出 |
| ゼロコスト✅ | 実行時のオーバーヘッドなし！ |
| 予測可能✅ | いつ解放されるか明確 |
| 安全✅ | ダングリングポインタ不可能 |

**コンパイラがチェックするから実行が遅くなることはない！**

---

## 比較まとめ

| 方法 | 安全性 | パフォーマンス | 開発体験 |
|------|--------|---------------|----------|
| 手動（C++）| ❌ 危険 | ✅ 速い | ❌ 地獄 |
| GC（Java等）| ✅ 安全 | ❌ 遅い | ✅ 楽 |
| **所有権（Rust）** | **✅ 安全** | **✅ 速い** | 🤔 学習曲線 |

**Rustは「安全」と「速い」を両立した革命的な言語！**

C++とかいうゴミ言語とは大違い。

---

## スタックとヒープ

基本的にスタックとヒープがある。これはC++も同じだしコンピュータはそう。

| | スタック | ヒープ |
|---|---------|--------|
| 速度 | 超速い | 遅い |
| サイズ | 固定 | 可変 |
| 管理 | 自動 | **手動/GC/所有権** |

### ヒープの厄介さ

ヒープは**ポインタで行ったり来たり**しなきゃいけないのが厄介。

```
スタック          ヒープ
┌─────────┐      ┌─────────────────┐
│ ptr ────┼─────→│ "hello world"   │
└─────────┘      └─────────────────┘
  どこにある？       ここにある
```

- どこで確保した？
- 誰が使ってる？
- いつ解放する？
- 誰が解放する？

**C++だとこの管理が地獄！**

**これも所有権が解決してくれる。**

> **この世の問題は全て所有権が解決してくれる**

---

## 🔥 所有権の3つのルール（超重要！）

**肝に銘じろ！**

| # | ルール | わかりやすく言うと |
|---|--------|-------------------|
| 1 | 各値には「所有者」と呼ばれる変数がある | **全ての値には持ち主がいる** |
| 2 | 所有者は常に1人だけ | **1つの値に2人の持ち主は存在しない** |
| 3 | 所有者がスコープを抜けたら値は破棄 | **持ち主がいなくなったら値も消える** |

### もっとわかりやすく

```rust
{
    let s = String::from("hello");  // s が "hello" の所有者
    // ここで s は有効
}   // ← スコープ終わり。s がいなくなる。"hello" も消える！
```

### 所有者は1人だけ！

```rust
let s1 = String::from("hello");
let s2 = s1;  // 所有権が s1 から s2 に移動（Move）

// println!("{}", s1);  // ❌ エラー！s1 はもう所有者じゃない！
println!("{}", s2);     // ✅ s2 が所有者！
```

**C++だったら両方使えてダングリングポインタの地獄💀**

---

## String型とメモリ

### 文字列リテラル vs String

```rust
let s1 = "hello";              // 文字列リテラル（バイナリにハードコード）
let s2 = String::from("hello"); // String型（ヒープに確保）
```

| | 文字列リテラル | String |
|---|---------------|--------|
| 保存場所 | バイナリ | ヒープ |
| サイズ | コンパイル時に決定 | 実行時に可変 |
| 可変性 | 不変 | 可変可能 |

### Stringのメモリ構造

![Stringのメモリ構造](../images/ch04_string_memory.png)

スタックに `ptr`, `len`, `capacity`。ヒープに実際のデータ。

---

## Move（ムーブ）

```rust
let s1 = String::from("hello");
let s2 = s1;  // s1 → s2 にムーブ！
```

![Move: s1が無効化される](../images/ch04_move.png)

**s1 と s2 が同じヒープを指すと、スコープ抜ける時に二重解放！**

→ だから Rust は **s1 を無効化** する！

```rust
let s1 = String::from("hello");
let s2 = s1;

// println!("{}", s1);  // ❌ エラー！s1 はもう使えない！
println!("{}", s2);     // ✅ OK
```

---

## Clone（クローン）= ガチコピー

ヒープのデータも含めて完全コピーしたい場合：

```rust
let s1 = String::from("hello");
let s2 = s1.clone();  // ガチコピー！

println!("{}", s1);  // ✅ OK
println!("{}", s2);  // ✅ OK
```

![Clone: 完全に別のメモリ](../images/ch04_clone.png)

**注意**: `clone()` は高コスト（ヒープにメモリ確保するから）

---

## Copy トレイト（スタックだけの型）

```rust
let x = 5;
let y = x;  // x も y も使える！矛盾してない？

println!("{}", x);  // ✅ OK
println!("{}", y);  // ✅ OK
```

**なぜ？** → 整数は `Copy` トレイトを持つ！

### Copy な型

| 型 | 説明 |
|----|------|
| `i32`, `u32`, 全整数型 | ✅ Copy |
| `f32`, `f64` | ✅ Copy |
| `bool` | ✅ Copy |
| `char` | ✅ Copy |
| `(i32, i32)` | ✅ Copy（中身が全部Copyなタプル）|
| `(i32, String)` | ❌ Move（Stringが入ってるから）|

**スタックだけの型はコピーが安いから Copy！**

---

## 関数と所有権

### 所有権を渡す（Move）

```rust
fn main() {
    let s = String::from("hello");
    takes_ownership(s);         // s がムーブされる！
    
    // println!("{}", s);       // ❌ もう使えない！
}

fn takes_ownership(some_string: String) {
    println!("{}", some_string);
}   // some_string がドロップされてメモリ解放
```

### Copyな型は大丈夫

```rust
fn main() {
    let x = 5;
    makes_copy(x);              // コピーされる
    
    println!("{}", x);          // ✅ まだ使える！
}

fn makes_copy(some_integer: i32) {
    println!("{}", some_integer);
}
```

### 図解

```
String を渡す:
main             takes_ownership
┌─────┐          ┌─────────────┐
│  s  │ ──Move──→│ some_string │
└─────┘          └─────────────┘
  ↓                    ↓
使えない！           使える→解放

i32 を渡す:
main             makes_copy
┌───┐            ┌──────────────┐
│ x │ ──Copy──→  │ some_integer │
└───┘            └──────────────┘
  ↓                    ↓
使える！            使える→終わり
```

---

## 「不便すぎ！」→ 借用で解決！

```rust
takes_ownership(s);  // 渡したら使えなくなる！不便！
```

**これを解決するのが「参照と借用」！次のセクションで！**

```rust
fn takes_reference(s: &String) {  // 借りるだけ！
    println!("{}", s);
}

let s = String::from("hello");
takes_reference(&s);  // 所有権は渡さない！
println!("{}", s);    // ✅ まだ使える！
```

---

## 💡 学んだこと

- メモリ管理には3つの方法がある
- 手動管理は危険すぎる（C++🤮）
- GCは安全だけど遅い
- Rustの所有権は**コンパイル時チェック**で両方の問題を解決！
- 文字列リテラルはバイナリ、Stringはヒープ
- **Move**: 所有権が移動して元の変数は使えなくなる
- **Clone**: ガチコピー（ヒープも含めて複製）
- **Copy**: スタックだけの型は自動コピー（整数、bool等）
- 関数に渡すとMoveされる（Copyな型は除く）
- 「不便！」→ 借用で解決！（次のセクション）
