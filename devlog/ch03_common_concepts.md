# 第3章: 一般的なプログラミング概念

📅 2026-01-02

---

## 変数と可変性

### デフォルトで不変！

```rust
let x = 5;    // 不変（変更不可）
let mut y = 5; // 可変（変更可能）
```

Rustはデフォルトで不変！C++と逆！

#### 🔬 実験！不変変数を変更しようとすると...

![不変変数を変更しようとするコード](../images/ch03_immutable_code.png)

![エラー！cannot assign twice to immutable variable](../images/ch03_immutable_error.png)

**エラー内容も超親切！**
- どの行が問題か教えてくれる
- `help: consider making this binding mutable` ← 直し方まで提案！

#### ✅ `mut` をつけると...

![mutをつけたコード](../images/ch03_mut_code.png)

![成功！](../images/ch03_mut_success.png)

動いた！🎉

### 不変変数 vs 定数

「不変ならそれ定数じゃん」って思ったけど違う！

```rust
const MAX_POINT: u32 = 100_000;  // 定数
let x = get_input();              // 不変変数
```

| 特徴 | `let x = 5;` (不変変数) | `const X: u32 = 5;` (定数) |
|------|------------------------|---------------------------|
| 値の決定 | **実行時**でもOK | **コンパイル時**に確定必須 |
| 型注釈 | 省略可能 | **必須** |
| シャドーイング | ✅ できる | ❌ できない |
| グローバルスコープ | ❌ 使えない | ✅ 使える |

**使い分け**:
- 定数: 設定値、マジックナンバー
- 不変変数: 標準入力、計算結果など実行時に決まる値

### 数値の区切り `100_000`

見やすくていい！Rust固有じゃなく最近の言語は対応してる。

| 言語 | 書き方 |
|------|--------|
| Rust | `100_000` |
| Python 3.6+ | `100_000` |
| Java 7+ | `100_000` |
| C++14+ | `100'000` ← シングルクォートきっしょ |

C++は `'` を使う変態仕様...

---

## シャドーイング

「不変変数なのに値変えられるの？」って思ったけど、これは**新しい変数を作ってる**！

```rust
let x = 5;       // x: i32
let x = x + 1;   // 新しい x を作成（前のxを「覆い隠す」）
```

**上書きじゃなくて「覆い被さる」感じ！**

#### 🔬 実験

![シャドーイングのコード](../images/ch03_shadow_code.png)

![結果 - スコープ抜けたら戻る！](../images/ch03_shadow_result.png)

- inner scope: x = 12（6 * 2）
- 外に出たら: x = 6（元に戻った！）

**スコープ抜けたら前の変数が復活する！**

### シャドーイング vs mut

```rust
// シャドーイング：型を変えられる！
let guess = "42";
let guess = guess.parse::<i32>().unwrap();  // String → i32 OK！

// mut：型は変えられない
let mut x = "hello";
x = 5;  // ❌ エラー！
```

**メリット**: `guess_str` と `guess_num` を作る必要がなくなる！

---

## 💡 学んだこと

- Rustはデフォルト不変（C++と逆！安全！）
- `mut` で可変にする
- `const` は**コンパイル時**に値が決まる必要がある
- `let` は**実行時**に値が決まってもOK
- `100_000` で数値を読みやすく書ける
- シャドーイングは**新しい変数を作る**（上書きじゃない）
- シャドーイングなら**型も変えられる**（mutでは無理）

